    // Reset a category
    resetCategory: (playerId, category) => {
      set((state) => {
        const playerScore = state.playerScores[playerId];
        if (!playerScore) return;

        playerScore.categories[category] = createCategoryScore();
        playerScore.total = computeTotal(playerScore.categories);
        playerScore.lastUpdated = new Date();
      });
    },

    // Complete scoring
    completeScoring: () => {
      set((state) => {
        if (state.gameMetadata) {
          state.gameMetadata.endTime = new Date();
        }
        for (const playerId in state.playerScores) {
          state.playerScores[playerId].isComplete = true;
        }
      });
    },

    // Get player score
    getPlayerScore: (playerId: string) => {
      return get().playerScores[playerId];
    },

    // Get all totals
    getAllTotals: () => {
      const scores = get().playerScores;
      const totals: Record<string, number> = {};
      for (const playerId in scores) {
        totals[playerId] = scores[playerId].total;
      }
      return totals;
    },

    // Check if game is complete
    isGameComplete: () => {
      const scores = get().playerScores;
      const metadata = get().gameMetadata;
      if (!metadata) return false;
      
      // Check if all enabled categories have scores for all players
      const enabledCategories = CATEGORY_KEYS.filter(cat => {
        if (cat === 'cities') return metadata.expansions.cities;
        if (cat === 'leaders') return metadata.expansions.leaders;
        if (cat === 'navy' || cat === 'islands') return metadata.expansions.armada;
        if (cat === 'edifice') return metadata.expansions.edifice;
        return true; // Base game categories
      });
      
      return Object.values(scores).every(score => 
        enabledCategories.every(cat => 
          score.categories[cat].directPoints !== null || 
          score.categories[cat].calculatedPoints !== undefined
        )
      );
    },

    // Get completion progress (0 to 1)
    getCompletionProgress: () => {
      const scores = get().playerScores;
      const metadata = get().gameMetadata;
      if (!metadata || Object.keys(scores).length === 0) return 0;
      
      const enabledCategories = CATEGORY_KEYS.filter(cat => {
        if (cat === 'cities') return metadata.expansions.cities;
        if (cat === 'leaders') return metadata.expansions.leaders;
        if (cat === 'navy' || cat === 'islands') return metadata.expansions.armada;
        if (cat === 'edifice') return metadata.expansions.edifice;
        return true;
      });
      
      const totalRequired = enabledCategories.length * Object.keys(scores).length;
      let completed = 0;
      
      Object.values(scores).forEach(score => {
        enabledCategories.forEach(cat => {
          if (score.categories[cat].directPoints !== null || 
              score.categories[cat].calculatedPoints !== undefined) {
            completed++;
          }
        });
      });
      
      return completed / totalRequired;
    },

    // Get leaderboard
    getLeaderboard: () => {
      const scores = get().playerScores;
      const leaderboard = Object.values(scores)
        .map((s) => ({ playerId: s.playerId, total: s.total, rank: 0 }))
        .sort((a, b) => b.total - a.total);

      leaderboard.forEach((entry, index) => {
        entry.rank = index + 1;
      });

      return leaderboard;
    },

    // Get category breakdown for a player
    getCategoryBreakdown: (playerId: string) => {
      const playerScore = get().playerScores[playerId];
      if (!playerScore) return {} as Record<CategoryKey, number>;
      
      const breakdown: Record<CategoryKey, number> = {} as any;
      CATEGORY_KEYS.forEach(cat => {
        breakdown[cat] = playerScore.categories[cat].directPoints ?? 
                        playerScore.categories[cat].calculatedPoints ?? 0;
      });
      
      return breakdown;
    },
  }))
);
